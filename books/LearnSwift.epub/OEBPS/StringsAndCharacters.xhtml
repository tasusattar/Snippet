<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
  	<link href="epub.css" media="all" rel="stylesheet" type="text/css" />
  	<script type="text/javascript" src="svg.js"></script>
  </head>
  <body id="conceptual_flow_with_tasks">
    <div class="content-wrapper">
      <div id="chapter_container" class='conceptualwithtasks'>
  <article class="chapter">
    <a id="TP40014097-CH7">&#x200c;</a><a id="TP40014097-CH7-ID285">&#x200c;</a>
    <h2 class="chapter-name">Strings and Characters</h2>
      
      	<section class="section">
      		<p class="para">A <em>string</em> is a series of characters, such as <code class="code-voice">&quot;hello, world&quot;</code> or <code class="code-voice">&quot;albatross&quot;</code>. Swift strings are represented by the <code class="code-voice">String</code> type. The contents of a <code class="code-voice">String</code> can be accessed in various ways, including as a collection of <code class="code-voice">Character</code> values.</p><p class="para">Swift’s <code class="code-voice">String</code> and <code class="code-voice">Character</code> types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as adding together two strings with the <code class="code-voice">+</code> operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift. You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing.</p><p class="para">Despite this simplicity of syntax, Swift’s <code class="code-voice">String</code> type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</p><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">Swift’s <code class="code-voice">String</code> type is bridged with Foundation’s <code class="code-voice">NSString</code> class. If you are working with the Foundation framework in Cocoa, the entire <code class="code-voice">NSString</code> API is available to call on any <code class="code-voice">String</code> value you create when type cast to <code class="code-voice">NSString</code>, as described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID343" href="TypeCasting.xhtml#TP40014097-CH22-ID343">AnyObject</a>. You can also use a <code class="code-voice">String</code> value with any API that requires an <code class="code-voice">NSString</code> instance.
    	</p>
    <p class="para">For more information about using <code class="code-voice">String</code> with Foundation and Cocoa, see <em class="u-book"><!-- a href="" target="_self" logicalPath="//apple_ref/doc/uid/TP40014216" -->Using Swift with Cocoa and Objective-C (Swift 2.1)<!-- /a --></em>.</p>
  </aside>
</div>

    		</section> 


      <section class="section">
	<a id="TP40014097-CH7-ID286">&#x200c;</a>
  <h3 class="section-name">String Literals</h3>
  <p class="para">You can include predefined <code class="code-voice">String</code> values within your code as <em>string literals</em>. A string literal is a fixed sequence of textual characters surrounded by a pair of double quotes (<code class="code-voice">&quot;&quot;</code>).</p><p class="para">Use a string literal as an initial value for a constant or variable:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someString</code> = <code class="s">&quot;Some string literal value&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Note that Swift infers a type of <code class="code-voice">String</code> for the <code class="code-voice">someString</code> constant, because it is initialized with a string literal value.</p><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">For information about using special characters in string literals, see <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID295" href="StringsAndCharacters.xhtml#TP40014097-CH7-ID295">Special Characters in String Literals</a>.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID287">&#x200c;</a>
  <h3 class="section-name">Initializing an Empty String</h3>
  <p class="para">To create an empty <code class="code-voice">String</code> value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new <code class="code-voice">String</code> instance with initializer syntax:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">emptyString</code> = <code class="s">&quot;&quot;</code>               <code class="c">// empty string literal</code></code></li>
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">anotherEmptyString</code> = <code class="vc">String</code>()  <code class="c">// initializer syntax</code></code></li>
            <li><code class="code-voice"><code class="c">// these two strings are both empty, and are equivalent to each other</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Find out whether a <code class="code-voice">String</code> value is empty by checking its Boolean <code class="code-voice">isEmpty</code> property:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">if</code> <code class="vc">emptyString</code>.<code class="vc">isEmpty</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;Nothing to see here&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;Nothing to see here&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID288">&#x200c;</a>
  <h3 class="section-name">String Mutability</h3>
  <p class="para">You indicate whether a particular <code class="code-voice">String</code> can be modified (or <em>mutated</em>) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it cannot be modified):</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">variableString</code> = <code class="s">&quot;Horse&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">variableString</code> += <code class="s">&quot; and carriage&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// variableString is now &quot;Horse and carriage&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">constantString</code> = <code class="s">&quot;Highlander&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">constantString</code> += <code class="s">&quot; and another Highlander&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// this reports a compile-time error - a constant string cannot be modified</code></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (<code class="code-voice">NSString</code> and <code class="code-voice">NSMutableString</code>) to indicate whether a string can be mutated.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID289">&#x200c;</a>
  <h3 class="section-name">Strings Are Value Types</h3>
  <p class="para">Swift’s <code class="code-voice">String</code> type is a <em>value type</em>. If you create a new <code class="code-voice">String</code> value, that <code class="code-voice">String</code> value is <em>copied</em> when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing <code class="code-voice">String</code> value is created, and the new copy is passed or assigned, not the original version. Value types are described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID88" href="ClassesAndStructures.xhtml#TP40014097-CH13-ID88">Structures and Enumerations Are Value Types</a>.</p><p class="para">Swift’s copy-by-default <code class="code-voice">String</code> behavior ensures that when a function or method passes you a <code class="code-voice">String</code> value, it is clear that you own that exact <code class="code-voice">String</code> value, regardless of where it came from. You can be confident that the string you are passed will not be modified unless you modify it yourself.</p><p class="para">Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.</p>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID290">&#x200c;</a>
  <h3 class="section-name">Working with Characters</h3>
  <p class="para">You can access the individual <code class="code-voice">Character</code> values for a <code class="code-voice">String</code> by iterating over its <code class="code-voice">characters</code> property with a <code class="code-voice">for</code>-<code class="code-voice">in</code> loop:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">character</code> <code class="kt">in</code> <code class="s">&quot;Dog!🐶&quot;</code>.<code class="vc">characters</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="vc">character</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// D</code></code></li>
            <li><code class="code-voice"><code class="c">// o</code></code></li>
            <li><code class="code-voice"><code class="c">// g</code></code></li>
            <li><code class="code-voice"><code class="c">// !</code></code></li>
            <li><code class="code-voice"><code class="c">// 🐶</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">The <code class="code-voice">for</code>-<code class="code-voice">in</code> loop is described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID121" href="ControlFlow.xhtml#TP40014097-CH9-ID121">For Loops</a>.</p><p class="para">Alternatively, you can create a stand-alone <code class="code-voice">Character</code> constant or variable from a single-character string literal by providing a <code class="code-voice">Character</code> type annotation:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">exclamationMark</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;!&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para"><code class="code-voice">String</code> values can be constructed by passing an array of <code class="code-voice">Character</code> values as an argument to its initializer:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">catCharacters</code>: [<code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code>] = [<code class="s">&quot;C&quot;</code>, <code class="s">&quot;a&quot;</code>, <code class="s">&quot;t&quot;</code>, <code class="s">&quot;!&quot;</code>, <code class="s">&quot;🐱&quot;</code>]</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">catString</code> = <code class="vc">String</code>(<code class="vc">catCharacters</code>)</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="vc">catString</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;Cat!🐱&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID291">&#x200c;</a>
  <h3 class="section-name">Concatenating Strings and Characters</h3>
  <p class="para"><code class="code-voice">String</code> values can be added together (or <em>concatenated</em>) with the addition operator (<code class="code-voice">+</code>) to create a new <code class="code-voice">String</code> value:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">string1</code> = <code class="s">&quot;hello&quot;</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">string2</code> = <code class="s">&quot; there&quot;</code></code></li>
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">welcome</code> = <code class="vc">string1</code> + <code class="vc">string2</code></code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello there&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">You can also append a <code class="code-voice">String</code> value to an existing <code class="code-voice">String</code> variable with the addition assignment operator (<code class="code-voice">+=</code>):</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">instruction</code> = <code class="s">&quot;look over&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">instruction</code> += <code class="vc">string2</code></code></li>
            <li><code class="code-voice"><code class="c">// instruction now equals &quot;look over there&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">You can append a <code class="code-voice">Character</code> value to a <code class="code-voice">String</code> variable with the <code class="code-voice">String</code> type’s <code class="code-voice">append()</code> method:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">exclamationMark</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;!&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">welcome</code>.<code class="vc">append</code>(<code class="vc">exclamationMark</code>)</code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello there!&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">You can’t append a <code class="code-voice">String</code> or <code class="code-voice">Character</code> to an existing <code class="code-voice">Character</code> variable, because a <code class="code-voice">Character</code> value must contain a single character only.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID292">&#x200c;</a>
  <h3 class="section-name">String Interpolation</h3>
  <p class="para"><em>String interpolation</em> is a way to construct a new <code class="code-voice">String</code> value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">multiplier</code> = <code class="m">3</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">message</code> = <code class="s">&quot;</code>\(<code class="vc">multiplier</code>)<code class="s"> times 2.5 is </code>\(<code class="vc">Double</code>(<code class="vc">multiplier</code>) * <code class="m">2.5</code>)<code class="s">&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// message is &quot;3 times 2.5 is 7.5&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In the example above, the value of <code class="code-voice">multiplier</code> is inserted into a string literal as <code class="code-voice">\(multiplier)</code>. This placeholder is replaced with the actual value of <code class="code-voice">multiplier</code> when the string interpolation is evaluated to create an actual string.</p><p class="para">The value of <code class="code-voice">multiplier</code> is also part of a larger expression later in the string. This expression calculates the value of <code class="code-voice">Double(multiplier) * 2.5</code> and inserts the result (<code class="code-voice">7.5</code>) into the string. In this case, the expression is written as <code class="code-voice">\(Double(multiplier) * 2.5)</code> when it is included inside the string literal.</p><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">The expressions you write inside parentheses within an interpolated string cannot contain an unescaped backslash (<code class="code-voice">\</code>), a carriage return, or a line feed. However, they can contain other string literals.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID293">&#x200c;</a>
  <h3 class="section-name">Unicode</h3>
  <p class="para"><em>Unicode</em> is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s <code class="code-voice">String</code> and <code class="code-voice">Character</code> types are fully Unicode-compliant, as described in this section.</p>
  <section class="section">
	<a id="TP40014097-CH7-ID294">&#x200c;</a>
  <h3 class="section-name">Unicode Scalars</h3>
  <p class="para">Behind the scenes, Swift’s native <code class="code-voice">String</code> type is built from <em>Unicode scalar</em> values. A Unicode scalar is a unique 21-bit number for a character or modifier, such as <code class="code-voice">U+0061</code> for <code class="code-voice">LATIN SMALL LETTER A</code> (<code class="code-voice">&quot;a&quot;</code>), or <code class="code-voice">U+1F425</code> for <code class="code-voice">FRONT-FACING BABY CHICK</code> (<code class="code-voice">&quot;🐥&quot;</code>).</p><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">A Unicode scalar is any Unicode <em>code point</em> in the range <code class="code-voice">U+0000</code> to <code class="code-voice">U+D7FF</code> inclusive or <code class="code-voice">U+E000</code> to <code class="code-voice">U+10FFFF</code> inclusive. Unicode scalars do not include the Unicode <em>surrogate pair</em> code points, which are the code points in the range <code class="code-voice">U+D800</code> to <code class="code-voice">U+DFFF</code> inclusive.
    	</p>
    
  </aside>
</div><p class="para">Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as <code class="code-voice">LATIN SMALL LETTER A</code> and <code class="code-voice">FRONT-FACING BABY CHICK</code> in the examples above.</p>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID295">&#x200c;</a>
  <h3 class="section-name">Special Characters in String Literals</h3>
  <p class="para">String literals can include the following special characters:</p><ul class="list-bullet">
  <li class="item"><p class="para">The escaped special characters <code class="code-voice">\0</code> (null character), <code class="code-voice">\\</code> (backslash), <code class="code-voice">\t</code> (horizontal tab), <code class="code-voice">\n</code> (line feed), <code class="code-voice">\r</code> (carriage return), <code class="code-voice">\&quot;</code> (double quote) and <code class="code-voice">\&#39;</code> (single quote)</p></li><li class="item"><p class="para">An arbitrary Unicode scalar, written as <code class="code-voice">\u{</code><em>n</em><code class="code-voice">}</code>, where <em>n</em> is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point</p></li>
</ul><p class="para">The code below shows four examples of these special characters. The <code class="code-voice">wiseWords</code> constant contains two escaped double quote characters. The <code class="code-voice">dollarSign</code>, <code class="code-voice">blackHeart</code>, and <code class="code-voice">sparklingHeart</code> constants demonstrate the Unicode scalar format:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">wiseWords</code> = <code class="s">&quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// &quot;Imagination is more important than knowledge&quot; - Einstein</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">dollarSign</code> = <code class="s">&quot;\u{24}&quot;</code>        <code class="c">// $,  Unicode scalar U+0024</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">blackHeart</code> = <code class="s">&quot;\u{2665}&quot;</code>      <code class="c">// ♥,  Unicode scalar U+2665</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">sparklingHeart</code> = <code class="s">&quot;\u{1F496}&quot;</code> <code class="c">// 💖, Unicode scalar U+1F496</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID296">&#x200c;</a>
  <h3 class="section-name">Extended Grapheme Clusters</h3>
  <p class="para">Every instance of Swift’s <code class="code-voice">Character</code> type represents a single <em>extended grapheme cluster</em>. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</p><p class="para">Here’s an example. The letter <code class="code-voice">é</code> can be represented as the single Unicode scalar <code class="code-voice">é</code> (<code class="code-voice">LATIN SMALL LETTER E WITH ACUTE</code>, or <code class="code-voice">U+00E9</code>). However, the same letter can also be represented as a <em>pair</em> of scalars—a standard letter <code class="code-voice">e</code> (<code class="code-voice">LATIN SMALL LETTER E</code>, or <code class="code-voice">U+0065</code>), followed by the <code class="code-voice">COMBINING ACUTE ACCENT</code> scalar (<code class="code-voice">U+0301</code>). The <code class="code-voice">COMBINING ACUTE ACCENT</code> scalar is graphically applied to the scalar that precedes it, turning an <code class="code-voice">e</code> into an <code class="code-voice">é</code> when it is rendered by a Unicode-aware text-rendering system.</p><p class="para">In both cases, the letter <code class="code-voice">é</code> is represented as a single Swift <code class="code-voice">Character</code> value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">eAcute</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{E9}&quot;</code>                         <code class="c">// é</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">combinedEAcute</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{65}\u{301}&quot;</code>          <code class="c">// e followed by ́</code></code></li>
            <li><code class="code-voice"><code class="c">// eAcute is é, combinedEAcute is é</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Extended grapheme clusters are a flexible way to represent many complex script characters as a single <code class="code-voice">Character</code> value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single <code class="code-voice">Character</code> value in Swift:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">precomposed</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{D55C}&quot;</code>                  <code class="c">// 한</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">decomposed</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{1112}\u{1161}\u{11AB}&quot;</code>   <code class="c">// ᄒ, ᅡ, ᆫ</code></code></li>
            <li><code class="code-voice"><code class="c">// precomposed is 한, decomposed is 한</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Extended grapheme clusters enable scalars for enclosing marks (such as <code class="code-voice">COMBINING ENCLOSING CIRCLE</code>, or <code class="code-voice">U+20DD</code>) to enclose other Unicode scalars as part of a single <code class="code-voice">Character</code> value:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">enclosedEAcute</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{E9}\u{20DD}&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// enclosedEAcute is é⃝</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Unicode scalars for regional indicator symbols can be combined in pairs to make a single <code class="code-voice">Character</code> value, such as this combination of <code class="code-voice">REGIONAL INDICATOR SYMBOL LETTER U</code> (<code class="code-voice">U+1F1FA</code>) and <code class="code-voice">REGIONAL INDICATOR SYMBOL LETTER S</code> (<code class="code-voice">U+1F1F8</code>):</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">regionalIndicatorForUS</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{1F1FA}\u{1F1F8}&quot;</code></code></li>
            <li><code class="code-voice"><code class="c">// regionalIndicatorForUS is 🇺🇸</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
	<a id="TP40014097-CH7-ID297">&#x200c;</a>
  <h3 class="section-name">Counting Characters</h3>
  <p class="para">To retrieve a count of the <code class="code-voice">Character</code> values in a string, use the <code class="code-voice">count</code> property of the string’s <code class="code-voice">characters</code> property:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">unusualMenagerie</code> = <code class="s">&quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;unusualMenagerie has </code>\(<code class="vc">unusualMenagerie</code>.<code class="vc">characters</code>.<code class="vc">count</code>)<code class="s"> characters&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;unusualMenagerie has 40 characters&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Note that Swift’s use of extended grapheme clusters for <code class="code-voice">Character</code> values means that string concatenation and modification may not always affect a string’s character count.</p><p class="para">For example, if you initialize a new string with the four-character word <code class="code-voice">cafe</code>, and then append a <code class="code-voice">COMBINING ACUTE ACCENT</code> (<code class="code-voice">U+0301</code>) to the end of the string, the resulting string will still have a character count of <code class="code-voice">4</code>, with a fourth character of <code class="code-voice">é</code>, not <code class="code-voice">e</code>:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">word</code> = <code class="s">&quot;cafe&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;the number of characters in </code>\(<code class="vc">word</code>)<code class="s"> is </code>\(<code class="vc">word</code>.<code class="vc">characters</code>.<code class="vc">count</code>)<code class="s">&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;the number of characters in cafe is 4&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="vc">word</code> += <code class="s">&quot;\u{301}&quot;</code>    <code class="c">// COMBINING ACUTE ACCENT, U+0301</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;the number of characters in </code>\(<code class="vc">word</code>)<code class="s"> is </code>\(<code class="vc">word</code>.<code class="vc">characters</code>.<code class="vc">count</code>)<code class="s">&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;the number of characters in café is 4&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">Extended grapheme clusters can be composed of one or more Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string cannot be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the <code class="code-voice">characters</code> property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.
    	</p>
    <p class="para">The count of the characters returned by the <code class="code-voice">characters</code> property is not always the same as the <code class="code-voice">length</code> property of an <code class="code-voice">NSString</code> that contains the same characters. The length of an <code class="code-voice">NSString</code> is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</p>
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID494">&#x200c;</a>
  <h3 class="section-name">Accessing and Modifying a String</h3>
  <p class="para">You access and modify a string through its methods and properties, or by using subscript syntax.</p>
  <section class="section">
	<a id="TP40014097-CH7-ID534">&#x200c;</a>
  <h3 class="section-name">String Indices</h3>
  <p class="para">Each <code class="code-voice">String</code> value has an associated <em>index type</em>, <code class="code-voice">String.Index</code>, which corresponds to the position of each <code class="code-voice">Character</code> in the string.</p><p class="para">As mentioned above, different characters can require different amounts of memory to store, so in order to determine which <code class="code-voice">Character</code> is at a particular position, you must iterate over each Unicode scalar from the start or end of that <code class="code-voice">String</code>. For this reason, Swift strings cannot be indexed by integer values.</p><p class="para">Use the <code class="code-voice">startIndex</code> property to access the position of the first <code class="code-voice">Character</code> of a <code class="code-voice">String</code>. The <code class="code-voice">endIndex</code> property is the position after the last character in a <code class="code-voice">String</code>. As a result, the <code class="code-voice">endIndex</code> property isn’t a valid argument to a string’s subscript. If a <code class="code-voice">String</code> is empty, <code class="code-voice">startIndex</code> and <code class="code-voice">endIndex</code> are equal.</p><p class="para">A <code class="code-voice">String.Index</code> value can access its immediately preceding index by calling the <code class="code-voice">predecessor()</code> method, and its immediately succeeding index by calling the <code class="code-voice">successor()</code> method. Any index in a <code class="code-voice">String</code> can be accessed from any other index by chaining these methods together, or by using the <code class="code-voice">advancedBy(_:)</code> method. Attempting to access an index outside of a string’s range will trigger a runtime error.</p><p class="para">You can use subscript syntax to access the <code class="code-voice">Character</code> at a particular <code class="code-voice">String</code> index.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">greeting</code> = <code class="s">&quot;Guten Tag!&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">greeting</code>[<code class="vc">greeting</code>.<code class="vc">startIndex</code>]</code></li>
            <li><code class="code-voice"><code class="c">// G</code></code></li>
            <li><code class="code-voice"><code class="vc">greeting</code>[<code class="vc">greeting</code>.<code class="vc">endIndex</code>.<code class="vc">predecessor</code>()]</code></li>
            <li><code class="code-voice"><code class="c">// !</code></code></li>
            <li><code class="code-voice"><code class="vc">greeting</code>[<code class="vc">greeting</code>.<code class="vc">startIndex</code>.<code class="vc">successor</code>()]</code></li>
            <li><code class="code-voice"><code class="c">// u</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">index</code> = <code class="vc">greeting</code>.<code class="vc">startIndex</code>.<code class="vc">advancedBy</code>(<code class="m">7</code>)</code></li>
            <li><code class="code-voice"><code class="vc">greeting</code>[<code class="vc">index</code>]</code></li>
            <li><code class="code-voice"><code class="c">// a</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Attempting to access a <code class="code-voice">Character</code> at an index outside of a string’s range will trigger a runtime error.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="vc">greeting</code>[<code class="vc">greeting</code>.<code class="vc">endIndex</code>] <code class="c">// error</code></code></li>
            <li><code class="code-voice"><code class="vc">greeting</code>.<code class="vc">endIndex</code>.<code class="vc">successor</code>() <code class="c">// error</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Use the <code class="code-voice">indices</code> property of the <code class="code-voice">characters</code> property to create a <code class="code-voice">Range</code> of all of the indexes used to access individual characters in a string.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">index</code> <code class="kt">in</code> <code class="vc">greeting</code>.<code class="vc">characters</code>.<code class="vc">indices</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">greeting</code>[<code class="vc">index</code>])<code class="s"> &quot;</code>, <code class="vc">terminator</code>: <code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;G u t e n   T a g !&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID496">&#x200c;</a>
  <h3 class="section-name">Inserting and Removing</h3>
  <p class="para">To insert a character into a string at a specified index, use the <code class="code-voice">insert(_:atIndex:)</code> method.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">welcome</code> = <code class="s">&quot;hello&quot;</code></code></li>
            <li><code class="code-voice"><code class="vc">welcome</code>.<code class="vc">insert</code>(<code class="s">&quot;!&quot;</code>, <code class="vc">atIndex</code>: <code class="vc">welcome</code>.<code class="vc">endIndex</code>)</code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello!&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">To insert the contents of another string at a specified index, use the <code class="code-voice">insertContentsOf(_:at:)</code> method.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="vc">welcome</code>.<code class="vc">insertContentsOf</code>(<code class="s">&quot; there&quot;</code>.<code class="vc">characters</code>, <code class="vc">at</code>: <code class="vc">welcome</code>.<code class="vc">endIndex</code>.<code class="vc">predecessor</code>())</code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello there!&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">To remove a character from a string at a specified index, use the <code class="code-voice">removeAtIndex(_:)</code> method.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="vc">welcome</code>.<code class="vc">removeAtIndex</code>(<code class="vc">welcome</code>.<code class="vc">endIndex</code>.<code class="vc">predecessor</code>())</code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello there&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">To remove a substring at a specified range, use the <code class="code-voice">removeRange(_:)</code> method:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">range</code> = <code class="vc">welcome</code>.<code class="vc">endIndex</code>.<code class="vc">advancedBy</code>(-<code class="m">6</code>)..&lt;<code class="vc">welcome</code>.<code class="vc">endIndex</code></code></li>
            <li><code class="code-voice"><code class="vc">welcome</code>.<code class="vc">removeRange</code>(<code class="vc">range</code>)</code></li>
            <li><code class="code-voice"><code class="c">// welcome now equals &quot;hello&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
	<a id="TP40014097-CH7-ID298">&#x200c;</a>
  <h3 class="section-name">Comparing Strings</h3>
  <p class="para">Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</p>
  <section class="section">
	<a id="TP40014097-CH7-ID299">&#x200c;</a>
  <h3 class="section-name">String and Character Equality</h3>
  <p class="para">String and character equality is checked with the “equal to” operator (<code class="code-voice">==</code>) and the “not equal to” operator (<code class="code-voice">!=</code>), as described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID70" href="BasicOperators.xhtml#TP40014097-CH6-ID70">Comparison Operators</a>:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">quotation</code> = <code class="s">&quot;We&#39;re a lot alike, you and I.&quot;</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">sameQuotation</code> = <code class="s">&quot;We&#39;re a lot alike, you and I.&quot;</code></code></li>
            <li><code class="code-voice"><code class="kt">if</code> <code class="vc">quotation</code> == <code class="vc">sameQuotation</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;These two strings are considered equal&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;These two strings are considered equal&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Two <code class="code-voice">String</code> values (or two <code class="code-voice">Character</code> values) are considered equal if their extended grapheme clusters are <em>canonically equivalent</em>. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</p><p class="para">For example, <code class="code-voice">LATIN SMALL LETTER E WITH ACUTE</code> (<code class="code-voice">U+00E9</code>) is canonically equivalent to <code class="code-voice">LATIN SMALL LETTER E</code> (<code class="code-voice">U+0065</code>) followed by <code class="code-voice">COMBINING ACUTE ACCENT</code> (<code class="code-voice">U+0301</code>). Both of these extended grapheme clusters are valid ways to represent the character <code class="code-voice">é</code>, and so they are considered to be canonically equivalent:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="c">// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E WITH ACUTE</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">eAcuteQuestion</code> = <code class="s">&quot;Voulez-vous un caf\u{E9}?&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="c">// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">combinedEAcuteQuestion</code> = <code class="s">&quot;Voulez-vous un caf\u{65}\u{301}?&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="kt">if</code> <code class="vc">eAcuteQuestion</code> == <code class="vc">combinedEAcuteQuestion</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;These two strings are considered equal&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;These two strings are considered equal&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Conversely, <code class="code-voice">LATIN CAPITAL LETTER A</code> (<code class="code-voice">U+0041</code>, or <code class="code-voice">&quot;A&quot;</code>), as used in English, is <em>not</em> equivalent to <code class="code-voice">CYRILLIC CAPITAL LETTER A</code> (<code class="code-voice">U+0410</code>, or <code class="code-voice">&quot;А&quot;</code>), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">latinCapitalLetterA</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{41}&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">cyrillicCapitalLetterA</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> = <code class="s">&quot;\u{0410}&quot;</code></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><code class="kt">if</code> <code class="vc">latinCapitalLetterA</code> != <code class="vc">cyrillicCapitalLetterA</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;These two characters are not equivalent&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;These two characters are not equivalent&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">String and character comparisons in Swift are not locale-sensitive.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID300">&#x200c;</a>
  <h3 class="section-name">Prefix and Suffix Equality</h3>
  <p class="para">To check whether a string has a particular string prefix or suffix, call the string’s <code class="code-voice">hasPrefix(_:)</code> and <code class="code-voice">hasSuffix(_:)</code> methods, both of which take a single argument of type <code class="code-voice">String</code> and return a Boolean value.</p><p class="para">The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s <em>Romeo and Juliet</em>:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">romeoAndJuliet</code> = [</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 1 Scene 1: Verona, A public place&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 1 Scene 2: Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 1 Scene 3: A room in Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 1 Scene 4: A street outside Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 1 Scene 5: The Great Hall in Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 1: Outside Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 2: Capulet&#39;s orchard&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 3: Outside Friar Lawrence&#39;s cell&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 4: A street in Verona&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 5: Capulet&#39;s mansion&quot;</code>,</code></li>
            <li><code class="code-voice">    <code class="s">&quot;Act 2 Scene 6: Friar Lawrence&#39;s cell&quot;</code></code></li>
            <li><code class="code-voice">]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">You can use the <code class="code-voice">hasPrefix(_:)</code> method with the <code class="code-voice">romeoAndJuliet</code> array to count the number of scenes in Act 1 of the play:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">act1SceneCount</code> = <code class="m">0</code></code></li>
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">scene</code> <code class="kt">in</code> <code class="vc">romeoAndJuliet</code> {</code></li>
            <li><code class="code-voice">    <code class="kt">if</code> <code class="vc">scene</code>.<code class="vc">hasPrefix</code>(<code class="s">&quot;Act 1 &quot;</code>) {</code></li>
            <li><code class="code-voice">        ++<code class="vc">act1SceneCount</code></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;There are </code>\(<code class="vc">act1SceneCount</code>)<code class="s"> scenes in Act 1&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;There are 5 scenes in Act 1&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Similarly, use the <code class="code-voice">hasSuffix(_:)</code> method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">mansionCount</code> = <code class="m">0</code></code></li>
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">cellCount</code> = <code class="m">0</code></code></li>
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">scene</code> <code class="kt">in</code> <code class="vc">romeoAndJuliet</code> {</code></li>
            <li><code class="code-voice">    <code class="kt">if</code> <code class="vc">scene</code>.<code class="vc">hasSuffix</code>(<code class="s">&quot;Capulet&#39;s mansion&quot;</code>) {</code></li>
            <li><code class="code-voice">        ++<code class="vc">mansionCount</code></code></li>
            <li><code class="code-voice">    } <code class="kt">else</code> <code class="kt">if</code> <code class="vc">scene</code>.<code class="vc">hasSuffix</code>(<code class="s">&quot;Friar Lawrence&#39;s cell&quot;</code>) {</code></li>
            <li><code class="code-voice">        ++<code class="vc">cellCount</code></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">mansionCount</code>)<code class="s"> mansion scenes; </code>\(<code class="vc">cellCount</code>)<code class="s"> cell scenes&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;6 mansion scenes; 2 cell scenes&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <aside class="aside">
    	<p class="aside-title uppercase">Note</p>
    	<p class="para">The <code class="code-voice">hasPrefix(_:)</code> and <code class="code-voice">hasSuffix(_:)</code> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID299" href="StringsAndCharacters.xhtml#TP40014097-CH7-ID299">String and Character Equality</a>.
    	</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
	<a id="TP40014097-CH7-ID301">&#x200c;</a>
  <h3 class="section-name">Unicode Representations of Strings</h3>
  <p class="para">When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined <em>encoding forms</em>. Each form encodes the string in small chunks known as <em>code units</em>. These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</p><p class="para">Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a <code class="code-voice">for</code>-<code class="code-voice">in</code> statement, to access its individual <code class="code-voice">Character</code> values as Unicode extended grapheme clusters. This process is described in <a rel="me" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID290" href="StringsAndCharacters.xhtml#TP40014097-CH7-ID290">Working with Characters</a>.</p><p class="para">Alternatively, access a <code class="code-voice">String</code> value in one of three other Unicode-compliant representations:</p><ul class="list-bullet">
  <li class="item"><p class="para">A collection of UTF-8 code units (accessed with the string’s <code class="code-voice">utf8</code> property)</p></li><li class="item"><p class="para">A collection of UTF-16 code units (accessed with the string’s <code class="code-voice">utf16</code> property)</p></li><li class="item"><p class="para">A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s <code class="code-voice">unicodeScalars</code> property)</p></li>
</ul><p class="para">Each example below shows a different representation of the following string, which is made up of the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, <code class="code-voice">g</code>, <code class="code-voice">‼</code> (<code class="code-voice">DOUBLE EXCLAMATION MARK</code>, or Unicode scalar <code class="code-voice">U+203C</code>), and the 🐶 character (<code class="code-voice">DOG FACE</code>, or Unicode scalar <code class="code-voice">U+1F436</code>):</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">dogString</code> = <code class="s">&quot;Dog‼🐶&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section>
  <section class="section">
	<a id="TP40014097-CH7-ID302">&#x200c;</a>
  <h3 class="section-name">UTF-8 Representation</h3>
  <p class="para">You can access a UTF-8 representation of a <code class="code-voice">String</code> by iterating over its <code class="code-voice">utf8</code> property. This property is of type <code class="code-voice">String.UTF8View</code>, which is a collection of unsigned 8-bit (<code class="code-voice">UInt8</code>) values, one for each byte in the string’s UTF-8 representation:</p><div class="figure">
	<span class="caption"></span>
	<img src="Art/UTF8_2x.png" alt="image: ../Art/UTF8_2x.png" width="476" height="229" />
</div><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">codeUnit</code> <code class="kt">in</code> <code class="vc">dogString</code>.<code class="vc">utf8</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">codeUnit</code>)<code class="s"> &quot;</code>, <code class="vc">terminator</code>: <code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// 68 111 103 226 128 188 240 159 144 182</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In the example above, the first three decimal <code class="code-voice">codeUnit</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>, whose UTF-8 representation is the same as their ASCII representation. The next three decimal <code class="code-voice">codeUnit</code> values (<code class="code-voice">226</code>, <code class="code-voice">128</code>, <code class="code-voice">188</code>) are a three-byte UTF-8 representation of the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character. The last four <code class="code-voice">codeUnit</code> values (<code class="code-voice">240</code>, <code class="code-voice">159</code>, <code class="code-voice">144</code>, <code class="code-voice">182</code>) are a four-byte UTF-8 representation of the <code class="code-voice">DOG FACE</code> character.</p>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID303">&#x200c;</a>
  <h3 class="section-name">UTF-16 Representation</h3>
  <p class="para">You can access a UTF-16 representation of a <code class="code-voice">String</code> by iterating over its <code class="code-voice">utf16</code> property. This property is of type <code class="code-voice">String.UTF16View</code>, which is a collection of unsigned 16-bit (<code class="code-voice">UInt16</code>) values, one for each 16-bit code unit in the string’s UTF-16 representation:</p><div class="figure">
	<span class="caption"></span>
	<img src="Art/UTF16_2x.png" alt="image: ../Art/UTF16_2x.png" width="477" height="229" />
</div><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">codeUnit</code> <code class="kt">in</code> <code class="vc">dogString</code>.<code class="vc">utf16</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">codeUnit</code>)<code class="s"> &quot;</code>, <code class="vc">terminator</code>: <code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// 68 111 103 8252 55357 56374</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Again, the first three <code class="code-voice">codeUnit</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</p><p class="para">The fourth <code class="code-voice">codeUnit</code> value (<code class="code-voice">8252</code>) is a decimal equivalent of the hexadecimal value <code class="code-voice">203C</code>, which represents the Unicode scalar <code class="code-voice">U+203C</code> for the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character. This character can be represented as a single code unit in UTF-16.</p><p class="para">The fifth and sixth <code class="code-voice">codeUnit</code> values (<code class="code-voice">55357</code> and <code class="code-voice">56374</code>) are a UTF-16 surrogate pair representation of the <code class="code-voice">DOG FACE</code> character. These values are a high-surrogate value of <code class="code-voice">U+D83D</code> (decimal value <code class="code-voice">55357</code>) and a low-surrogate value of <code class="code-voice">U+DC36</code> (decimal value <code class="code-voice">56374</code>).</p>
  
</section>
<section class="section">
	<a id="TP40014097-CH7-ID304">&#x200c;</a>
  <h3 class="section-name">Unicode Scalar Representation</h3>
  <p class="para">You can access a Unicode scalar representation of a <code class="code-voice">String</code> value by iterating over its <code class="code-voice">unicodeScalars</code> property. This property is of type <code class="code-voice">UnicodeScalarView</code>, which is a collection of values of type <code class="code-voice">UnicodeScalar</code>.</p><p class="para">Each <code class="code-voice">UnicodeScalar</code> has a <code class="code-voice">value</code> property that returns the scalar’s 21-bit value, represented within a <code class="code-voice">UInt32</code> value:</p><div class="figure">
	<span class="caption"></span>
	<img src="Art/UnicodeScalar_2x.png" alt="image: ../Art/UnicodeScalar_2x.png" width="477" height="229" />
</div><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">scalar</code> <code class="kt">in</code> <code class="vc">dogString</code>.<code class="vc">unicodeScalars</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">scalar</code>.<code class="vc">value</code>)<code class="s"> &quot;</code>, <code class="vc">terminator</code>: <code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// 68 111 103 8252 128054</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">The <code class="code-voice">value</code> properties for the first three <code class="code-voice">UnicodeScalar</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) once again represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>.</p><p class="para">The fourth <code class="code-voice">codeUnit</code> value (<code class="code-voice">8252</code>) is again a decimal equivalent of the hexadecimal value <code class="code-voice">203C</code>, which represents the Unicode scalar <code class="code-voice">U+203C</code> for the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character.</p><p class="para">The <code class="code-voice">value</code> property of the fifth and final <code class="code-voice">UnicodeScalar</code>, <code class="code-voice">128054</code>, is a decimal equivalent of the hexadecimal value <code class="code-voice">1F436</code>, which represents the Unicode scalar <code class="code-voice">U+1F436</code> for the <code class="code-voice">DOG FACE</code> character.</p><p class="para">As an alternative to querying their <code class="code-voice">value</code> properties, each <code class="code-voice">UnicodeScalar</code> value can also be used to construct a new <code class="code-voice">String</code> value, such as with string interpolation:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">for</code> <code class="vc">scalar</code> <code class="kt">in</code> <code class="vc">dogString</code>.<code class="vc">unicodeScalars</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;</code>\(<code class="vc">scalar</code>)<code class="s"> &quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// D</code></code></li>
            <li><code class="code-voice"><code class="c">// o</code></code></li>
            <li><code class="code-voice"><code class="c">// g</code></code></li>
            <li><code class="code-voice"><code class="c">// ‼</code></code></li>
            <li><code class="code-voice"><code class="c">// 🐶</code></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>

  </article>
</div>

    </div>
  </body>
</html>
